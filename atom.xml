<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Peter_zwu]]></title>
  <subtitle><![CDATA[简约不简单]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zhurch.com/"/>
  <updated>2015-11-23T02:35:34.677Z</updated>
  <id>http://www.zhurch.com/</id>
  
  <author>
    <name><![CDATA[zhurch]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android Fragment 为什么推荐用bundle进行值传递]]></title>
    <link href="http://www.zhurch.com/2015/11/23/Android-Fragment-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%94%A8bundle%E8%BF%9B%E8%A1%8C%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://www.zhurch.com/2015/11/23/Android-Fragment-为什么推荐用bundle进行值传递/</id>
    <published>2015-11-23T02:09:41.000Z</published>
    <updated>2015-11-23T02:35:34.677Z</updated>
    <content type="html"><![CDATA[<p>当我们实例化自定义Fragment时，为什么官方推荐Fragment.setArguments(Bundle bundle)这种方式来传递参数，而不推荐通过构造方法直接来传递参数呢？ </p>
<blockquote>
<p>通过构造方法传递参数的情况</p>
</blockquote>
<pre><code>
public class FramentTestActivity extends ActionBarActivity {  
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    if (savedInstanceState == null) {
      getSupportFragmentManager().beginTransaction()
          .add(R.id.container, new TestFragment("param")).commit();
    }    
  }
public static class TestFragment extends Fragment {
    private String mArg = "non-param";    
    public TestFragment() {
      Log.i("INFO", "TestFragment non-parameter constructor");
    }    
    public TestFragment(String arg){
      mArg = arg;
      Log.i("INFO", "TestFragment construct with parameter");
    }
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
      View rootView = inflater.inflate(R.layout.fragment_main, container,
          false);
      TextView tv = (TextView) rootView.findViewById(R.id.tv);
      tv.setText(mArg);
      return rootView;
    }
  }
}
</code></pre>
![](file:///F:/1.jpg)

传递过来的数据正确的显示了，现在来考虑一个问题，如果设备配置参数发生变化(横竖屏切换)，显示如下....为什么会显示默认值？
![](file:///F:/2.jpg)

> Fragment.setArguments(Bundle bundle)这种方式的运行情况

<pre><code>
public class FramentTest2Activity extends ActionBarActivity {       
        @Override
        protected void onCreate(Bundle savedInstanceState) {
             super.onCreate(savedInstanceState);
             setContentView(R.layout. activity_main);
             if (savedInstanceState == null) {
                  getSupportFragmentManager().beginTransaction()
                 .add(R.id. container, TestFragment.newInstance("param")).commit();
             }
        }
       public static class TestFragment extends Fragment {
             private static final String ARG = "arg";             
             public TestFragment() {
                     Log. i("INFO", "TestFragment non-parameter constructor" );
             }
             public static Fragment newInstance(String arg){
                     TestFragment fragment = new TestFragment();
                     Bundle bundle = new Bundle();
                     bundle.putString( ARG, arg);
                     fragment.setArguments(bundle);
                     return fragment;
             }             
              @Override
              public View onCreateView(LayoutInflater inflater, ViewGroup container,
               Bundle savedInstanceState) {
                        View rootView = inflater.inflate(R.layout. fragment_main,                                 container, false);
                        TextView tv = (TextView) rootView.findViewById(R.id. tv);
                        tv.setText(getArguments().getString( ARG));
                     return rootView;
             }
       }
}
</code></pre>

<p>横竖屏切换后的运行情况<br><img src="file:///F:/3.jpg" alt=""></p>
<hr>
<blockquote>
<p>设备横竖屏切换的话，当前展示给用户的Activity默认情况下会重新创建并展现给用户，那依附于Activity的Fragment会进行如何处理呢，<br>由于我们的Fragment是由FragmentManager来管理，在FragmentManager.restoreAllState()方法中，通过调用FragmentState的instantiate方法创建Fragment，FragmentState.instantitate()方法的实现<br>最终会通过反射无参构造实例化一个新的Fragment，并且给mArgments初始化为原先的值，而原来的Fragment实例的数据都丢失了，并重新进行了初始化</p>
</blockquote>
<p>######通过上面的分析，我们可以知道Activity重新创建时，会重新构建它所管理的Fragment，原先的Fragment的字段值将会全部丢失，但是通过 Fragment.setArguments(Bundle bundle)方法设置的bundle会保留下来。所以尽量使用 Fragment.setArguments(Bundle bundle)方式来传递参数</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我们实例化自定义Fragment时，为什么官方推荐Fragment.setArguments(Bundle bundle)这种方式来传递参数，而不推荐通过构造方法直接来传递参数呢？ </p>
<blockquote>
<p>通过构造方法传递参数的情况</p>
</bloc]]>
    </summary>
    
      <category term="Android,Fragment" scheme="http://www.zhurch.com/tags/Android-Fragment/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <link href="http://www.zhurch.com/2015/11/20/11%E6%9C%8820%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>http://www.zhurch.com/2015/11/20/11月20日学习日记/</id>
    <published>2015-11-20T01:52:31.000Z</published>
    <updated>2015-11-20T02:08:37.056Z</updated>
    <content type="html"><![CDATA[<p> 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>  适用性</p>
<pre><code><span class="number">1.</span>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。

<span class="number">2.</span>一个对象引用其他很多对象并且直接与这些对象通信,导致难以复*该对象。

<span class="number">3.</span>想定制一个分布在多个类中的行为，*又不想生成太多的子类。
</code></pre><p>  参与者</p>
<pre><code><span class="number">1.</span>Mediator
  中介者定义一个接口用于与各同事（Colleague）对象通信。

<span class="number">2.</span>ConcreteMediator
  具*中介者通过协调各同事对象实现协作行为*
  了解并维护它的各个同事。

<span class="number">3.</span>Colleagueclass
  每一个同事类都知道它的中介者对象。
  每一个同事对象在需与其他的同事通信的时候*与它的中介者通信
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p> 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>  适用性</p>
<pre><code><span class="number">1.</span>一组对象以定义良好但是复杂的方式进行]]>
    </summary>
    
      <category term="java" scheme="http://www.zhurch.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://www.zhurch.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
